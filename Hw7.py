#  Весь код должен быть написан на верхнем уровне (без определения def или class).
# Создайте словарь rooms, где ключами будут имена комнат (например, "зал",
# "библиотека", "кухня"), а значениями – вложенные словари с такими ключами:
rooms = {
"зал": {
"описание": "Вы находитесь в большом зале с высоким потолком.",
"предметы": ["ключ", "картина", 'ключ'],
"выходы": {"север": "библиотека", "восток": "кухня"}
},
"библиотека":{
"описание": 'Вы находитесь в просторной библиотеке с огромным количесвом книг',
"предметы": ['бумага', 'книга', 'ручка', 'картина'],
"выходы": {"юг": "зал", "восток": "кухня"}
},
"кухня": {
"описание": 'Классическая кухня средневекового замка',
"предметы": ['стол', 'вилка', 'нож', 'ключ'],
"выходы": {"юг": "зал", "север": "библиотека"}
}
}

stop_words = ('д', 'yes', 'y', 'выйти', 'да')  # tuple
game_flag = True
room_flag = True
action_flag = False
inventory_dict = {} # словарь ключ-прдмет, значение- кол-во его добавлений
inventory_list = []  # список добавленных предметов для подсчета предметов
rooms_visit_lst = []  # список для будущего подсчета посещений комнат


while game_flag:

    if room_flag:
        current_room = input('Выберите начальную комнату(зал/библиотека/кухня): ').lower()
        if current_room in rooms:  # проверка наличия введенной комнаты в словаре(по умолчанию поиск по ключам)
            rooms_visit_lst.append(current_room)  # в список комнат добавляем первую выбранную для будущего посчета посещений
            print(f'Вы находитесь в комнате: {current_room}\n\
    описание комнаты: {rooms[current_room]['описание']}\n\
    доступные предметы в комнате: {', '.join(rooms[current_room]['предметы'])}\n\
    доступные направления: {', '.join(rooms[current_room]['выходы'].keys())}')   # Вывод информ о комнате
            room_flag = False
            action_flag = True
        else:  # если комната введена неверно, то новый ввод(попытки неограничены)
            print('Такой комнаты нет, повторите ввод: ')

    if action_flag:   # переходим к самой игре с выбором действий
        action_input = input('Что делаем дальше? Варианты:\n\n\
    1) идем в другую сторону(куда)?\n\
    2) берем предмет(какой)) \n\
    3) заканчиваем(да/y/yes)?\n\n\
    Твой выбор: ').split(' ')  # Разбиваем строку ввода на элементы списка (для строк из неск эл-ов)
        selection_result = action_input.pop()  # Выдергиваем последний элемент списка,что будет искомым ключом(если введен запрос типа: "идем на север" или "давай возьмем нож")
        if selection_result in rooms[current_room]['выходы']:  # по ТЗ проверяем ввод на соответствие в значениях(список)  влож.словаря с ключом ['выходы']
            print(f'Идем в {rooms[current_room]['выходы'][selection_result]}')            
            current_room = rooms[current_room]['выходы'][selection_result]  # Переназначаем текущую комнату
            rooms_visit_lst.append(current_room)  # добавляем комнату в список посещений комнат            
            print(f'Вы находитесь в комнате: {current_room}\n\
    описание комнаты: {rooms[current_room]['описание']}\n\
    доступные предметы в комнате: {', '.join(rooms[current_room]['предметы'])}\n\
    доступные направления: {', '.join(rooms[current_room]['выходы'].keys())}')
        
        elif selection_result in rooms[current_room]['предметы']:   # проверка ввода на соответствие в значениях(списке) влож.словаря по ключу ['предметы']
            inventory_list.append(selection_result)  # добавляем предмет в список предметов для подсчета            
            inventory_dict = {invent: inventory_list.count(invent)   # строки 72-73 заменил генератором словаря(также не вызывает KeyError) просто 
                              for invent in set(inventory_list)}   # для вариации(стр 72-73 удалять не стал так как там метод update также для вариции на тему)
            # for invent in inventory_list:  # пробежимся по списку предметов, чтобы одновить словарь
            #     inventory_dict.update({invent: inventory_list.count(invent)})  # обновляем словарь инвентаря(значения ключей), а именно кол-во инвентаря методом update(), что исключает Keyerror в случае отсутсвия ключа в словаре            
            rooms[current_room]['предметы'].remove(selection_result)  # Удаляем из изначального словаря забранный предмет согласно ТЗ            
            print(f'\nТы выбрал <{selection_result}>\nВ комнате остались предметы: {', '.join(rooms[current_room]['предметы'])}\n' if
                  rooms[current_room]['предметы'] else 'Больше предметов в комнате нет\n')   # Выводим оставшиеся в комнате предметы
    
        elif selection_result in stop_words:   # вариант остановки программы
            print('КОНЕЦ', '_______________', sep='\n' )            
            rooms_visit_dict = {room: rooms_visit_lst.count(room)  # генератор словаря согласно ТЗ для формирования словаря посещений комнат
                                for room in set(rooms_visit_lst)}            
            for key, value in rooms_visit_dict.items():      # вывод данных о посещениях комнат с помощью items()-ключ/значение(кортеж).
                print(f'в комнате: <<{key}>> вы были {value} раз(а)')             
            print()            
            if inventory_list:
                for key, value in inventory_dict.items():   # вывод данных о собранных предметах с помощью items()-ключ/значение(кортеж).
                    print(f'предмет: <<{key}>> вы собрали: {value} раз(а)') 
            else:
                print('Ваш инвентарь пуст')      
            game_flag = False
        
        else:
            print('Ошибка! Повтори ввод')


# P.S. так как работа идет с вложенными словарями, то чет get() я сюда пихать не стал(не увидел куда его здесь прям нужно применить)
# Да и записи вида dict.get(key, {}).get(key, {}).get(key) как-то громоздко)) 
