# Вы – коллекционер редких артефактов, и ваша задача – собрать уникальные предметы,
# разбросанные по карте. Каждый предмет может встретиться несколько раз, но в вашем
# арсенале должны остаться только уникальные экземпляры.
# items = ["амулет", "меч", "щит", "амулет", "кольцо", "щит"]


# Функция, возвращающая множество уникальных предметов из изначального списка
def unique_items(items_lst):
    items_set = set(items_lst)
    return items_set


# Функция, удаляющая предмет. Входные аргументы - список предметов и удаляемый предмет
def delete_item(items_lst, item=None):
    items_set = set(items_lst)
    items_set.discard(item)
    return items_set


# Функция, реализующая объединение множеств, использую метод union()
def union_set(items_lst, change_lst):
    return set(items_lst).union(change_lst)

# print(unique_items(items)) # Выводим уникальное множество
# print(delete_item(items, 'щит')) # Удаляем предмет
# print(union_set(items, ['sword', 'меч', 'клинок', 'яд', 'щит', 'амулет'])) # Выводим объеденение множеств

# _________________________
# Игра «Сражение Множеств»
# Сценарий:
# Два клана сражаются за контроль над территорией. Каждый клан представлен
# множеством, содержащим имена его воинов. В сражении важны операции пересечения
# (общие воины, которые могут перейти на сторону победителя) и разности (уникальные
# воины, остающиеся в своём клане).


clan_A = {'Педро', 'Влад', 'Борис', 'Артур', 'Гурген'}
clan_B = {'Гурген', 'Вазген', 'Ашот', 'Карэн', 'Педро'}


# Функция, определящая общих  воинов(пересечение) и симметрическую разность
def warriors(set_a, set_b):
    warriors_intersection = set_a & set_b
    warriors_symmetric_diff = set_a ^ set_b
    return f'-Общие воины в обоих кланах: {warriors_intersection}\n-Воины,\
 присутствующие только в одном из кланов: {warriors_symmetric_diff}'
    

# Функция обновления состава (update)
def warriors_update(clan_set, warriors_update_lst=None):
    clan_set.update(warriors_update_lst)  # обновляем существующее множество
    return clan_set  # возращаем обновленное(измененное) множество


# print(warriors(clan_A, clan_B)) # Вызываем фуекцию пересечения и симметрической разности
# print(warriors_update(clan_A, ['Федя', 'Мухтар', 'Эдмонд']))


# _______________________________
# 3. Игра «Побег из Лабиринта с Множествами»
# Сценарий:
# Вы оказались в лабиринте, где каждую дверь можно открыть, применив правильную
# комбинацию операций с множествами. Чтобы выбраться, нужно решить


codes1 = {"A1", "B2", "C3"}
codes2 = {"C3", "D4", "E5"}


# Объединение
def codes_union(set_1, set_2):
    return set_1 | set_2


# Пересечение
def codes_intersection(set_1, set_2):
    return set_1 & set_2


# Разность
def diff_update(set_1, set_2):
    return set_1 - set_2


# print(codes_union(codes1, codes2))
# print(codes_intersection(codes1, codes2))
# print(diff_update(codes1,codes2))


# ________________________________
# 4. Игра «Неподвижный Сундук (Frozenset Challenge)»
# Сценарий:
# Вы нашли древний сундук, который может быть открыт только с помощью неизменяемого
# набора ключей (frozenset). Чтобы собрать правильный набор, вам нужно преобразовать
# изменяемый список ключей в frozenset и выполнить несколько проверок.

keys = ["ключ1", "ключ2", "ключ3", "ключ1", "ключ4"]


# Создаем frozenset из списка
def frozen_keys(keys_lst):
    keys_set = frozenset(keys_lst)
    return keys_set


# создаем новый frozenset для добавления ключа(ей)
def new_key_add(frozen_set, key):
    return frozen_set | frozenset(key)
    

# создаем словарь из нового множества(ключом является frozenset)
keys_dict = {new_key_add(frozen_keys(keys), ['fff', 'fff', 'ffdd', 'ключ1']): 'Этот сундук имеет слишком много замков, не так ли?'}

# print(frozen_keys(keys))
# print(new_key_add(frozen_keys(keys), ['fff', 'fff', 'ffdd', 'ключ1']))
# print(keys_dict)


# _________________________________
# 5. Игра «Магический Компремехенс»
# Сценарий:
# В волшебном мире магия чисел основана на использовании множеств и их
# компрехеншенов. Вам нужно создать магический набор чисел, отвечающий
# определённым условиям, чтобы произвести заклинание.

# Напишите однострочное выражение с использованием множественного компрехеншена
# для создания множества квадратов чисел от 1 до 10.
squares = {x ** 2 for x in range(1, 11)}


# Добавьте условие, чтобы в множество попали только те квадраты, которые меньше 50.
squares_lim = {x ** 2 for x in range(1, 11) if (x ** 2) < 50}


print(squares)
print(squares_lim)