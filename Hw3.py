
# numbers_str = ["10", "20", "44о", "30", "40"]

# Из списка numbers_str выберите элемент с индексом 2.

# print(numbers_str[2])

# Попробуйте преобразовать выбранный элемент в целое число с использованием
# конструкции try/except.
# • Если преобразование проходит успешно, продолжите обработку.
# • Если преобразование невозможно, с помощью оператора raise выбросите исключение с
# соответствующим сообщением

# try:
#     if numbers_str[2].isdigit() is False:  
#         raise ValueError("Ошибка: преобразование строки в число невозможно")
#     number = int(numbers_str[2])
# except ValueError as e:
#     print(e)
# else:
    
#     if number % 2 == 0:
#         print(f'преобразование прошло успешно! Имеем четное число = {number}')
#     else:
#         print(f'преобразование прошло успешно! Имеем нечетное число = {number}') 
# finally:
#     print('попытка преобразования завершена!')


# • Сформируйте подсписок, содержащий первые три элемента исходного списка
# numbers_str, используя срезы.
# • Измените последний элемент полученного подсписка на строку "изменено".
# • Выведите созданный подсписок.

# new_numbers_str = numbers_str[:3]
# new_numbers_str[2] = 'изменено'
# print(new_numbers_str)

# ________________________________
# Задание 2: Проверка и обновление списка строк (фруктов)
# fruits = ["яблоко", "банан", "", "вишня", "манго"]
# Из списка fruits выберите элемент с индексом 2.
# • Если выбранный элемент является пустой строкой, с помощью оператора if выбросьте
# исключение с помощью raise и сообщением об ошибке (например, “Найдена пустая
# строка в списке фруктов!”).
# try:
#     if fruits[2] == '':
#         raise ValueError("Ошибка: Найдена пустая строка в списке фруктов!")
# except ValueError as e:
#     print(e)

# finally:
#     print('проверка завершена')


# Если в списке обнаружена пустая строка, замените её на значение "unknown", используя
# условный оператор (тернарный оператор).

# fruits[2] = 'unknown' if fruits[2] == '' else fruits[2] 
# print(fruits)


# Добавьте новый фрукт "инжир" в конец списка с помощью операции конкатенации
# (оператор +).

# fruits += ['инжир']
# print(fruits)

# Сформируйте подсписок, состоящий из элементов с индексами 1, 2 и 3 (используя срезы),
# и выведите его.
# new_fruits = fruits[1:4]
# print(new_fruits)

# ____________________________________________
# Задачи из бота
# 1.Программа деления:

# Напишите программу, которая запрашивает у пользователя два числа 
# и выводит их частное. Обработайте ситуацию, когда пользователь вводит 
# не число, а текст, и случай деления на ноль.

# try:
#     a, b = [int(input('введи по очереди 2 числа: ')) for i in range(2)]
#     if b > a:
#         raise Exception('b must be > a')  # пробуем отловить ошибку по своему условию и передать в exept Exception
#     result = round(a / b, 4)
#     print('result = ', result)
# except ValueError:
#     print('error: integer only')
# except ZeroDivisionError:
#     print("error: devider can't be zero")
# except Exception as e:
#     print(e)

# ______________________________________________________________
# 2. Простой арифметический калькулятор с проверкой оператора

# Описание:

# Напишите программу, которая запрашивает у пользователя:

# • Арифметическую операцию в виде символа (+, -, * или /).

# • Два числа (операнды).

# Реализуйте следующую логику:

# 3. Если введённый символ не является одним из разрешённых (+, -, *, /), с помощью оператора raise сгенерируйте исключение ValueError с сообщением о недопустимом операторе.

# 4. Попробуйте преобразовать введённые операнды в числа.

# 5. Если операция деления (/) и второй операнд равен нулю, сгенерируйте исключение ZeroDivisionError.

# 6. Если ошибок нет, выполните операцию и выведите результат (код выполнения в блоке else).

# 7. В блоке finally выведите сообщение «Расчёт завершён».

# operand_list = ['+', '-', '*', '/']

# try:
#     operand = input(''' Input one of: +, -, *, / ''')
#     if operand not in operand_list:
#         raise ValueError('Incorrect operand')
#     a, b = [int(input('введи по очереди 2 числа: ')) for i in range(2)]
#     if operand == '/' and b == 0:
#         raise ZeroDivisionError("Error: devider can't be zero")
    
# except ValueError as e:
#     print(e)
# except ZeroDivisionError as e:
#     print(e)

# else:
#     if operand == '+':
#         result = a + b
#     elif operand == '-':
#         result = a - b
#     elif operand == '*':
#         result = a * b
#     elif operand == '/':
#         result = a / b
#     print('Result = ', result)
# finally:
#     print('Calculation finished')


# _____________________________________________________
# 3. Вычисление квадратного корня

# Описание:

# Напишите программу, которая запрашивает у пользователя число и пытается вычислить его квадратный корень. Реализуйте следующую логику:

# 1. Преобразуйте введённое значение в число.

# 2. Если число отрицательное, с помощью оператора raise сгенерируйте исключение ValueError с сообщением о невозможности вычислить квадратный корень из отрицательного числа.

# 3. Если число неотрицательное, вычислите квадратный корень (можно воспользоваться выражением число ** 0.5) и выведите результат (используйте блок else).

# 4. В блоке finally выведите сообщение, что операция вычисления завершена.

# Требования к обработке исключений:

# • Обработайте ValueError, возникающее как при неверном формате ввода, так и при отрицательном значении.

# Подсказка:

# Помните, что блок finally выполнится в любом случае, независимо от того, возникло исключение или нет.

# try:
#     try:
#         n = int(input(' Enter count: '))
#     except ValueError:
#         raise ValueError("Ошибка: преобразование строки в число невозможно")

#     if n < 0:
#         raise ValueError('Не может быть отрицательным')            
# except ValueError as e:
#     print(e)
# else:
#     n = n ** 0.5
#     print('result = ', round(n, 3))
# finally:
#     print('Операция завершена')

# ____________________________________________
# 4. Вложенные конструкции:

# Напишите пример с вложенными блоками try/except, где внутренний блок обрабатывает 
# специфическую ошибку (например, деление на ноль), а внешний – перехватывает все 
# остальные исключения. Продемонстрируйте, как управление передается от внутреннего 
# к внешнему блоку.
# try:
#     n = int(input('Введи число: '))
#     try: 
#         result = 2929348 / n
#     except ZeroDivisionError:
#         raise ZeroDivisionError('нет уж! Только не ноль')
# except ValueError:
#     print('Error: integer only')
# except ZeroDivisionError as e:
#     print(e)
# except Exception as e:
#     print(e)
# else: 
#     print(result)
    
        